const std = @import("std");
const Allocator = std.mem.Allocator;

const spec_test_options = @import("spec_test_options");

pub fn main() !void {
    const allocator = std.heap.smp_allocator;
    const tests = &[_][]const u8{
        "general",
        "minimal",
        "mainnet",
    };
    try write_version();
    for (tests) |test_name| {
        try download_and_extract_spec_test(
            allocator,
            spec_test_options.spec_test_url,
            spec_test_options.spec_test_version,
            test_name,
            spec_test_options.spec_test_out_dir,
        );
    }
}

fn write_version() !void {
    const version_file = try std.fs.cwd().createFile("test/spec/version.txt", .{});
    defer version_file.close();

    var writer = version_file.writer().any();
    try writer.print(
        \\// This file is generated by download_spec_tests.zig.
        \\// This file exists as a cache key for the spec tests in CI.
        \\// Do not commit changes by hand.
        \\
        \\{s}
        \\
    , .{spec_test_options.spec_test_version});
}

fn download_and_extract_spec_test(
    allocator: Allocator,
    spec_test_url: []const u8,
    spec_test_version: []const u8,
    test_name: []const u8,
    out_dir: []const u8,
) !void {
    try download_spec_test_archive(allocator, spec_test_url, spec_test_version, test_name, out_dir);
    try extract_spec_test_archive(allocator, spec_test_version, test_name, out_dir);
}

fn download_spec_test_archive(
    allocator: Allocator,
    spec_test_url: []const u8,
    spec_test_version: []const u8,
    test_name: []const u8,
    out_dir: []const u8,
) !void {
    const filename = try std.fmt.allocPrint(allocator, "{s}.tar.gz", .{test_name});
    defer allocator.free(filename);

    const archive_dirname = try std.fs.path.join(allocator, &[_][]const u8{ out_dir, spec_test_version });
    defer allocator.free(archive_dirname);

    std.fs.cwd().makePath(archive_dirname) catch {};
    const archive_dir = try std.fs.cwd().openDir(archive_dirname, .{});

    const already_downloaded = archive_dir.openFile(filename, .{}) catch null;
    if (already_downloaded != null) {
        std.log.info("already downloaded {s}", .{filename});
        already_downloaded.?.close();
        return;
    }

    var file = try archive_dir.createFile(filename, .{});
    defer file.close();

    std.log.info("downloading spec test {s} {s}", .{ spec_test_version, test_name });

    var client: std.http.Client = .{ .allocator = allocator };
    defer client.deinit();

    const url = try std.fmt.allocPrint(
        allocator,
        "{s}/releases/download/{s}/{s}.tar.gz",
        .{
            spec_test_url,
            spec_test_version,
            test_name,
        },
    );
    defer allocator.free(url);

    std.log.info("spec test url: {s}", .{url});

    const uri = try std.Uri.parse(url);

    var server_header_buffer: [16 * 1024]u8 = undefined;

    var req = try client.open(.GET, uri, .{
        .server_header_buffer = &server_header_buffer,
    });
    defer req.deinit();

    std.log.info("sending request", .{});
    try req.send();

    try req.wait();

    // write to disk

    std.log.info("writing response to disk - {s}", .{filename});

    var buf = try allocator.alloc(u8, 16 * 1024000);
    defer allocator.free(buf);
    var reader = req.reader();
    var bytes_count: usize = 0;
    while (true) {
        const read_bytes = try reader.readAll(buf);
        try file.writeAll(buf[0..read_bytes]);
        bytes_count += read_bytes;
        if (read_bytes != buf.len) {
            break;
        }
    }
    std.log.info("response written to disk - {d} bytes", .{bytes_count});
}

fn extract_spec_test_archive(
    allocator: Allocator,
    spec_test_version: []const u8,
    test_name: []const u8,
    out_dir: []const u8,
) !void {
    const archive_dirname = try std.fs.path.join(allocator, &[_][]const u8{ out_dir, spec_test_version });
    defer allocator.free(archive_dirname);

    const filename = try std.fmt.allocPrint(allocator, "{s}.tar.gz", .{test_name});
    defer allocator.free(filename);

    const archive_dir = try std.fs.cwd().openDir(archive_dirname, .{});

    const already_extracted = archive_dir.openDir(test_name, .{}) catch null;
    if (already_extracted != null) {
        std.log.info("already extracted {s}", .{filename});
        return;
    }

    const archive_file = try archive_dir.openFile(filename, .{});
    defer archive_file.close();

    archive_dir.makeDir(test_name) catch {};
    const extracted_out = try archive_dir.openDir(test_name, .{});

    const file_reader = archive_file.reader();

    var decompressor = std.compress.gzip.decompressor(file_reader);

    const gzip_reader = decompressor.reader();

    std.log.info("extracting {s}", .{filename});

    try std.tar.pipeToFileSystem(extracted_out, gzip_reader, .{});
    std.log.info("extract {s} complete", .{filename});
}
